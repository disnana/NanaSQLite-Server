import asyncio
import ssl
from aioquic.asyncio import QuicConnectionProtocol, connect
from aioquic.quic.configuration import QuicConfiguration
from aioquic.quic.events import StreamDataReceived
from cryptography.hazmat.primitives import serialization
import protocol

PRIVATE_KEY_PATH = "nana_private.pem"

class TestClientProtocol(QuicConnectionProtocol):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._responses = asyncio.Queue()

    def quic_event_received(self, event):
        if isinstance(event, StreamDataReceived):
            message, _ = protocol.decode_message(event.data)
            self._responses.put_nowait(message)

    async def send_raw(self, data):
        stream_id = self._quic.get_next_available_stream_id()
        payload = protocol.encode_message(data)
        self._quic.send_stream_data(stream_id, payload, end_stream=True)
        self.transmit()
        return await asyncio.wait_for(self._responses.get(), timeout=5.0)

def load_private_key():
    with open(PRIVATE_KEY_PATH, "rb") as f:
        return serialization.load_pem_private_key(f.read(), password=None)

async def create_connection(host="127.0.0.1", port=4433):
    configuration = QuicConfiguration(
        is_client=True,
        verify_mode=ssl.CERT_NONE,
        server_name="localhost",
    )
    ctx = connect(host, port, configuration=configuration, create_protocol=TestClientProtocol)
    connection = await ctx.__aenter__()
    return ctx, connection

async def test_exploit_close():
    print("Testing if we can call 'close' on the shared DB...")
    private_key = load_private_key()
    ctx, conn = await create_connection()
    try:
        # Authenticate
        challenge_msg = await conn.send_raw("AUTH_START")
        challenge = challenge_msg.get("data")
        signature = private_key.sign(challenge)
        await conn.send_raw({"type": "response", "data": signature})

        # Call close()
        print("Sending 'close' method call...")
        result = await conn.send_raw({"method": "close", "args": [], "kwargs": {}})
        print(f"Result of close(): {result}")

        # Try to call another method
        print("Trying to call 'set' after 'close'...")
        result2 = await conn.send_raw({"method": "set", "args": ["key", "val"], "kwargs": {}})
        print(f"Result of set(): {result2}")

    except Exception as e:
        print(f"Error: {e}")
    finally:
        conn.close()
        await conn.wait_closed()

if __name__ == "__main__":
    asyncio.run(test_exploit_close())
