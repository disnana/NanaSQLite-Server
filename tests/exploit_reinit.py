import asyncio
import ssl
from aioquic.asyncio import QuicConnectionProtocol, connect
from aioquic.quic.configuration import QuicConfiguration
from aioquic.quic.events import StreamDataReceived
from cryptography.hazmat.primitives import serialization
from nanasqlite_server import protocol
import os

PRIVATE_KEY_PATH = "nana_private.pem"
PORT = int(os.environ.get("NANASQLITE_TEST_PORT", 4433))


class TestClientProtocol(QuicConnectionProtocol):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._responses = asyncio.Queue()

    def quic_event_received(self, event):
        if isinstance(event, StreamDataReceived):
            message, _ = protocol.decode_message(event.data)
            self._responses.put_nowait(message)

    async def send_raw(self, data):
        stream_id = self._quic.get_next_available_stream_id()
        payload = protocol.encode_message(data)
        self._quic.send_stream_data(stream_id, payload, end_stream=True)
        self.transmit()
        return await asyncio.wait_for(self._responses.get(), timeout=5.0)


def load_private_key():
    with open(PRIVATE_KEY_PATH, "rb") as f:
        return serialization.load_pem_private_key(f.read(), password=None)


async def create_connection(host="127.0.0.1", port=PORT):
    configuration = QuicConfiguration(
        is_client=True,
        verify_mode=ssl.CERT_NONE,
        server_name="localhost",
    )
    ctx = connect(
        host, port, configuration=configuration, create_protocol=TestClientProtocol
    )
    connection = await ctx.__aenter__()
    return ctx, connection


async def test_exploit_reinit():
    print("Testing if we can call '__init__' on the shared DB...")
    private_key = load_private_key()
    ctx, conn = await create_connection()
    try:
        # Authenticate
        challenge_msg = await conn.send_raw("AUTH_START")
        challenge = challenge_msg.get("data")
        signature = private_key.sign(challenge)
        await conn.send_raw({"type": "response", "data": signature})

        # Set a key
        await conn.send_raw({"method": "set", "args": ["key", "val"], "kwargs": {}})
        print("Set key=val")

        # Call __init__ with a different db file
        print("Sending '__init__' method call to change DB file...")
        result = await conn.send_raw(
            {"method": "__init__", "args": ["exploited.sqlite"], "kwargs": {}}
        )
        print(f"Result of __init__(): {result}")

        # Check if key still exists
        result2 = await conn.send_raw({"method": "get", "args": ["key"], "kwargs": {}})
        print(f"Result of get('key'): {result2}")

        if result2.get("result") is None:
            print("VULNERABILITY CONFIRMED: DB was re-initialized!")
        else:
            print("DB was not re-initialized as expected.")

    except Exception as e:
        print(f"Error: {e}")
    finally:
        conn.close()
        await conn.wait_closed()
        if os.path.exists("exploited.sqlite"):
            os.remove("exploited.sqlite")


if __name__ == "__main__":
    asyncio.run(test_exploit_reinit())
