"""
NanaSQLite-Server 認証脆弱性検証スクリプト

このスクリプトは以下の脆弱性を検証します：
1. AUTH_STARTをスキップしてresponseを送信した場合の挙動
2. 認証済み状態で再度AUTH_STARTを送信した場合の挙動
3. 無効な署名による認証試行とBAN機能の動作確認
4. ブロッキングの検証（重いDB操作中に他のクライアントが待たされるか）
"""

import asyncio
import ssl
import time
from aioquic.asyncio import QuicConnectionProtocol, connect
from aioquic.quic.configuration import QuicConfiguration
from aioquic.quic.events import StreamDataReceived
from cryptography.hazmat.primitives import serialization
import os
from nanasqlite_server import protocol

PRIVATE_KEY_PATH = "nana_private.pem"
PORT = int(os.environ.get("NANASQLITE_TEST_PORT", 4433))


class TestClientProtocol(QuicConnectionProtocol):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._responses = asyncio.Queue()

    def quic_event_received(self, event):
        if isinstance(event, StreamDataReceived):
            message, _ = protocol.decode_message(event.data)
            self._responses.put_nowait(message)

    async def send_raw(self, data):
        stream_id = self._quic.get_next_available_stream_id()
        payload = protocol.encode_message(data)
        self._quic.send_stream_data(stream_id, payload, end_stream=True)
        self.transmit()
        return await asyncio.wait_for(self._responses.get(), timeout=5.0)


def load_private_key():
    with open(PRIVATE_KEY_PATH, "rb") as f:
        return serialization.load_pem_private_key(f.read(), password=None)


async def create_connection(host="127.0.0.1", port=PORT):
    configuration = QuicConfiguration(
        is_client=True,
        verify_mode=ssl.CERT_NONE,
        server_name="localhost",
    )
    ctx = connect(host, port, configuration=configuration, create_protocol=TestClientProtocol)
    connection = await ctx.__aenter__()
    return ctx, connection


# =============================================================================
# テスト1: AUTH_STARTをスキップしてresponseを送信
# =============================================================================
async def test_skip_auth_start():
    print("\n" + "=" * 60)
    print("TEST 1: AUTH_START をスキップして response を送信")
    print("=" * 60)
    
    ctx, conn = await create_connection()
    try:
        # いきなりresponseを送信（チャレンジなし）
        fake_signature = b"fake_signature_without_challenge"
        result = await conn.send_raw({"type": "response", "data": fake_signature})
        print(f"  結果: {result}")
        
        if result == "AUTH_FAILED":
            print("  ✓ 期待通り AUTH_FAILED が返されました (セキュア)")
        elif isinstance(result, dict) and "error" in str(result).lower():
            print("  ⚠ サーバーがエラーを返しました（クラッシュはしていない）")
            print(f"    詳細: {result}")
        else:
            print(f"  ✗ 予期しない応答: {result}")
    except Exception as e:
        print(f"  ⚠ 例外発生: {type(e).__name__}: {e}")
    finally:
        conn.close()
        await conn.wait_closed()


# =============================================================================
# テスト2: 認証済み状態で再度AUTH_STARTを送信
# =============================================================================
async def test_reauth_after_authenticated():
    print("\n" + "=" * 60)
    print("TEST 2: 認証済み状態で再度 AUTH_START を送信")
    print("=" * 60)
    
    private_key = load_private_key()
    ctx, conn = await create_connection()
    try:
        # 正規の認証フロー
        challenge_msg = await conn.send_raw("AUTH_START")
        if not isinstance(challenge_msg, dict) or challenge_msg.get("type") != "challenge":
            print(f"  ✗ チャレンジ取得失敗: {challenge_msg}")
            return
        
        challenge = challenge_msg.get("data")
        signature = private_key.sign(challenge)
        result = await conn.send_raw({"type": "response", "data": signature})
        
        if result != "AUTH_OK":
            print(f"  ✗ 認証失敗: {result}")
            return
        
        print("  認証成功")
        
        # 認証済み状態で再度AUTH_STARTを送信
        result2 = await conn.send_raw("AUTH_START")
        print(f"  再AUTH_START の結果: {result2}")
        
        if isinstance(result2, dict) and result2.get("status") == "error":
            print("  ✓ エラーとして処理されました (セキュア)")
        elif isinstance(result2, dict) and result2.get("type") == "challenge":
            print("  ⚠ 新しいチャレンジが発行されました（再認証の可能性）")
        else:
            print(f"  ? 不明な挙動: {result2}")
    except Exception as e:
        print(f"  ⚠ 例外発生: {type(e).__name__}: {e}")
    finally:
        conn.close()
        await conn.wait_closed()


# =============================================================================
# テスト3: 無効な署名によるBAN機能の検証
# =============================================================================
async def test_ban_mechanism():
    print("\n" + "=" * 60)
    print("TEST 4: 無効な署名による BAN 機能の検証")
    print("=" * 60)
    
    for attempt in range(5):
        ctx, conn = await create_connection()
        try:
            # チャレンジ取得
            challenge_msg = await conn.send_raw("AUTH_START")
            if not isinstance(challenge_msg, dict):
                print(f"  Attempt {attempt + 1}: チャレンジ取得失敗 - {challenge_msg}")
                continue
            
            challenge_msg.get("data")
            
            # 無効な署名を送信
            fake_signature = b"invalid_signature_" + str(attempt).encode()
            result = await conn.send_raw({"type": "response", "data": fake_signature})
            print(f"  Attempt {attempt + 1}: {result}")
            
            if result == "AUTH_BANNED":
                print("  ✓ BANが機能しました")
                break
        except Exception as e:
            print(f"  Attempt {attempt + 1}: 例外 - {type(e).__name__}: {e}")
        finally:
            conn.close()
            await conn.wait_closed()
        
        await asyncio.sleep(0.1)


# =============================================================================
# テスト4: ブロッキングの検証（複数クライアント同時接続）
# =============================================================================
async def test_blocking_behavior():
    print("\n" + "=" * 60)
    print("TEST 3: ブロッキングの検証（同時接続）")
    print("=" * 60)
    
    private_key = load_private_key()
    
    async def authenticated_client(client_id: int):
        ctx, conn = await create_connection()
        try:
            # 認証
            challenge_msg = await conn.send_raw("AUTH_START")
            challenge = challenge_msg.get("data")
            signature = private_key.sign(challenge)
            await conn.send_raw({"type": "response", "data": signature})
            
            # 重いDB操作（大量のデータ書き込み）
            start = time.perf_counter()
            for i in range(10):
                await conn.send_raw({
                    "method": "__setitem__",
                    "args": [f"blocking_test_{client_id}_{i}", {"data": "x" * 1000}],
                    "kwargs": {}
                })
            elapsed = time.perf_counter() - start
            return client_id, elapsed
        finally:
            conn.close()
            await conn.wait_closed()
    
    # 3つのクライアントを同時に実行
    print("  3つのクライアントを同時に接続してDB操作を実行...")
    start_total = time.perf_counter()
    
    try:
        results = await asyncio.gather(
            authenticated_client(1),
            authenticated_client(2),
            authenticated_client(3),
            return_exceptions=True
        )
        
        total_elapsed = time.perf_counter() - start_total
        
        for result in results:
            if isinstance(result, Exception):
                print(f"  ⚠ エラー: {result}")
            else:
                client_id, elapsed = result
                print(f"  Client {client_id}: {elapsed:.3f}秒")
        
        print(f"  合計時間: {total_elapsed:.3f}秒")
        
        # 各クライアントの時間の合計と全体時間を比較
        individual_times = [r[1] for r in results if not isinstance(r, Exception)]
        if individual_times:
            sum_individual = sum(individual_times)
            if total_elapsed > sum_individual * 0.8:
                print("  ⚠ ブロッキングの可能性あり（逐次実行に近い）")
            else:
                print("  ✓ 並列実行されている可能性が高い")
    except Exception as e:
        print(f"  ⚠ テスト失敗: {e}")


async def main():
    print("=" * 60)
    print(" NanaSQLite-Server 認証脆弱性検証")
    print("=" * 60)
    print("注意: このスクリプトを実行する前にサーバーを起動してください")
    print("      python server.py")
    
    await test_skip_auth_start()
    await test_reauth_after_authenticated()
    await test_blocking_behavior()
    # BANテストは最後に実行（BANされると他のテストが失敗するため）
    await test_ban_mechanism()
    
    print("\n" + "=" * 60)
    print(" 検証完了")
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())
